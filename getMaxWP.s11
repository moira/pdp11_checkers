.=torg+2000

main:	mov #WinParam,-(sp)
		mov #DstPos,-(sp)
		mov #SrcPos,-(sp)
		jsr pc,getMaxWP
		add #6,sp
		halt


;Function that gives best move for a given state on the board
;WinParam: 6(sp)
;DstPos: 4(sp)
;SrcPos: 2(sp)

getMaxWP:			mov #-21,@6(sp) 		;initializing WinParam to minus infinity
					cmp #1, @#timeOut		;checking if the time is out
					bne GMWPcont			;if not - branching to "GMWPcont"
					rts pc 					;returning from subroutine
GMWPcont:			mov #0,-(sp)			;passing first output field for "endCond"
					mov #0,-(sp) 			;passing second output field for "endCond"
					mov @#Steps,-(sp) 		;passing steps as parameter for "endCond"
					mov #Board,-(sp) 		;passing board as parameter for "endCond"
					mov @#Player,-(sp) 		;passing current player as parameter for "endCond"
					jsr pc,endCond 			;calling "endCond"
					add #6,sp 				;clearing irrelevant stack area
					cmp #1,2(sp) 			;checking if there is end condition satisfied
					beq endPut 				;branching to "endPut"
					cmp #2,2(sp)			;if there is pass cond satisfied
					beq pasVar 				;branching to "pasVar"
					br fMovScan         	;branching to "fMovScan"

pasVar:				add #4,sp   			;clearing stack
					mov #0,-(sp) 			;passing output field for "scanMov"
					mov #Player,-(sp) 		;passing original player for "scanMov"
					mov #Board,-(sp) 		;passing board for "scanMov"
					mov @#Steps,-(sp) 		;passing steps for "scanMov"
					dec (sp) 				;decrementing steps passed for "scanMov"
					mov @#Player,-(sp) 		;passing current player for "scanMov"
					jsr pc,switchPl 		;inverting player
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack
					mov (sp),@10(sp) 		;changing WinParam
					tst (sp)+ 				;clearing stack
					mov #0,-(sp)			;passing output field for "getAnyF"
					mov #Board,-(sp)		;passing board for "getAnyF"
					mov @#Player,-(sp)		;passing player for "getAnyF"
					jsr pc,getAnyF			;calling "getAnyF"
					add #4,sp 				;clearing stack
					mov (sp),@6(sp) 		;assigning destination to DstPos label
					mov (sp),@4(sp) 		;assigning source to SrcPos label
					tst (sp)+ 				;clearing stack
					rts pc			 		;returning from subroutine

endPut:				mov (sp),@12(sp) 		;putting winning parameter into output field
					add #4,sp 				;clearing irrelevant stack area
					mov #0,-(sp)			;passing output field for "getAnyF"
					mov #Board,-(sp)		;passing board for "getAnyF"
					mov @#Player,-(sp)		;passing player for "getAnyF"
					jsr pc,getAnyF			;calling "getAnyF"
					add #4,sp 				;clearing stack
					mov (sp),@6(sp) 		;assigning destination to DstPos label
					mov (sp),@4(sp) 		;assigning source to SrcPos label
					tst (sp)+ 				;clearing stack
					rts pc  				;returning from subroutine

sEndJ:				jmp fMovEnd				;jumping to "scanEnd"

fMovScan:			add #4,sp               ;clearing stack
					mov #-1,-(sp)			;creates an iterator to count steps
					mov #Board,-(sp)		;creates a copy of the board address
					sub #2,(sp)				;sets the current address to the word just before the board for convenient iteration

fMovLoop:			cmp #1,@#timeOut 		;checking if time is out
					bne FMLC				;if no - branching to 'FMLC'
					br sEndJ 				;otherwise, branching to 'sEndJ'
					add #2,(sp)				;increments the address in order for it to point to the next square
					inc 2(sp)				;increments the number of the square (from 0 to 77)
					cmp 2(sp),#100			;checks if there are any squares left ;should be 77, this is a test version
					bge sEndJ				;if there are none, ends iteration					
					cmp @(sp),@#Player		;does the square contain the token of the original player
					bne fMovLoop			;if it doesn't, just continue to iterate over squares

recFMov:			mov 2(sp),-(sp)			;passing current source as parameter for "canMoveR"
					mov 2(sp),-(sp) 		;passing board as parameter for "canMoveR"
					mov @#Player,-(sp) 		;passing current player as parameter for "canMoveR"
					jsr pc,canMoveR 		;calling "canMoveR"
					add #4,sp 				;clearing stack
					cmp #-1,(sp) 			;checking if there are moves on the right path
					beq fMovLP 				;if no - branching to "fMovLP", otherwise - proceeding
					mov #Board,-(sp)		;passing board as parameter for "movPiece"(3 stack elements, last - dest)
					mov 6(sp),src1			;passing current source as parameter for "movPiece"
					mov 2(sp),dst1			;passing found destination as parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
src1:				.word 0 				;inline parameter for "movPiece"
dst1:				.word 0 				;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack(nse=3)
					mov #0,-(sp)     		;passing output field for "scanMov"
					mov #Player,-(sp) 		;passing original player as parameter for "scanMov" 
					mov #Board,-(sp) 		;passing board as parameter for "scanMov"
					mov @#Steps,-(sp)		;passing steps as parameter for "scanMov"
					dec (sp) 				;decrementing steps passed to "scanMov"
					mov @#Player,-(sp) 		;passing current player as parameter for "scanMov"
					jsr pc,switchPl 		;inverting current player passed to "scanMov"
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack(nse=4, last=winparam)
					mov #0,-(sp)			;index to identify that we are checking right path(nse=5, last=pathindex)
					cmp @20(sp),2(sp) 		;checking if WP returned by internal "scanMov" is different from current WP
					bne chPar 				;if yes - branching to "chWP", otherwise proceeding to "retInPos"
					mov (sp),2(sp)			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retInPos 			;branching to "retInPos"

fMovLP:				tst (sp)+				;clearing stack
					mov 2(sp),-(sp)			;passing current source as parameter for "canMoveL"
					mov 2(sp),-(sp) 		;passing board as parameter for "canMoveL"
					mov @#Player,-(sp) 		;passing original player as parameter for "canMoveL"
					jsr pc,canMoveL 		;calling "canMoveL"
					add #4,sp 				;clearing stack
					cmp #-1,(sp) 			;checking if there are moves on the left path
					beq retToFL				;if no - branching to "retToFL", otherwise - proceeding
					mov #Board,-(sp)		;passing board as parameter for "movPiece"(3 stack elements, last - dest)
					mov 6(sp),src2			;passing current source as parameter for "movPiece"
					mov 2(sp),dst2			;passing found destination as parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
src2:				.word 0 				;inline parameter for "movPiece"
dst2:				.word 0 				;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack(nse=3)
					mov #0,-(sp)     		;passing output field for "scanMov"
					mov #Player,-(sp) 		;passing original player as parameter for "scanMov" 
					mov #Board,-(sp) 		;passing board as parameter for "scanMov"
					mov @#Steps,-(sp)		;passing steps as parameter for "scanMov"
					dec (sp) 				;decrementing steps passed to "scanMov"
					mov @#Player,-(sp) 		;passing current player as parameter for "scanMov"
					jsr pc,switchPl 		;inverting current player passed to "scanMov"
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack(nse=4, last=winparam)
					mov #1,-(sp)			;index to identify that we are checking left path(nse=5, last=pathindex)
					cmp @20(sp),2(sp) 		;checking if WP returned by internal "scanMov" is different from current WP
					bne chPar 				;if yes - branching to "chPar", otherwise proceeding to "retInPos"
					mov (sp),2(sp)			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retInPos 			;branching to "retInPos"

retToFL:			tst (sp)+ 				;clearing stack
					br JFMLoop 				;branching to "JFMLoop"

retInPos:			mov #Board,-(sp)        ;passing board as parameter for "movPiece"
					mov 4(sp),dst12			;passing dest as first parameter for "movPiece"
					mov 10(sp),src12		;passing source as first parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
dst12:				.word 0 				;inline parameter for "movPiece"
src12:				.word 0					;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack
					mov (sp),2(sp)			;changing position of psth index in stack
					tst (sp)+   			;clearing stack(nse=3, last=pathindex)
					cmp (sp)+,#0 			;checking if path is right
					bne JFMLoop 			;if yes proceeding to check left path, otherwise - continue iteration
					mov #0,-(sp)			;moving junk to the stack
					br fMovLP				;branching to "fMovLP"

JFMLoop:			jmp fMovLoop			;jumping to "fMovLoop"

chPar:				cmp @20(sp),2(sp) 		;checking if current WP is less that gotten from internal "scanMov"
					blt nParam 				;if yes - branching to "nParam", otherwise proceeding 
					mov (sp),2(sp) 			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retInPos 			;branching to "retInPos"

nParam:				mov 2(sp),@20(sp)		;assigning internal WP into the output field
					mov (sp),2(sp)	 		;moving path index down the stack
					tst (sp)+				;clearing stack(nse=4, last=pathindex)
					mov 2(sp),@14(sp)		;moving destination to the DstPos label
					mov 6(sp),@12(sp) 		;moving source to the SrcPos label
					br retInPos 			;branching to "retInPos"

fMovEnd:			add #4,sp				;deletes the count of steps and the copy of the board
					rts pc 					;returning from subroutine


;Recursive function for scanning through game nodes
;Output field: 12(sp)
;Original player: 10(sp)
;Board: 6(sp)
;Steps: 4(sp)
;Current player: 2(sp)

scanMov:			cmp #1,@#timeOut 		;checking if time is out
					bne recPr 				;if not - branching to recPr
					rts pc 					;retruning from subroutine
recPr:				mov r4,-(sp)   			;saving r4's content
					mov 4(sp),-(sp)			;passing current player as parameter for "minOrMax"
					mov 14(sp),-(sp)		;passing original player as parameter for "minOrMax"
					jsr pc,minOrMax			;calling "minOrMax"
					add #4,sp 				;clearing stack
					cmp r4,#-1 				;checking if we need to find min or max
					beq minInit 			;branching to "minInit"

maxInit:			mov (sp)+,r4 			;returning r4 to it's initial value
					mov #-21,12(sp) 		;initializing output
					br scMInit 				;branching to "scMInit"

minInit:			mov (sp)+,r4 			;returning r4 to it's initial value
					mov #21,12(sp) 			;initializing output

scMInit:			mov #0,-(sp)			;passing first output field for "endCond"
					mov #0,-(sp) 			;passing second output field for "endCond"
					mov 10(sp),-(sp) 		;passing steps as parameter for "endCond"
					mov 14(sp),-(sp) 		;passing board as parameter for "endCond"
					mov 12(sp),-(sp) 		;passing current player as parameter for "endCond"
					jsr pc,endCond 			;calling "endCond"
					add #6,sp 				;clearing irrelevant stack area
					cmp #1,2(sp) 			;checking if there is end condition satisfied
					beq endPutWP 			;if yes - branching to "endPutWP"
					cmp #2,2(sp) 			;checking if pass cond satisfied
					beq pVari 				;if yes - branching to "pVari"
					br scanB         		;branching to "scanB"

pVari:				add #4,sp   			;clearing stack
					mov #0,-(sp) 			;passing output field for "scanMov"
					mov 12(sp),-(sp) 		;passing original player for "scanMov"
					mov 12(sp),-(sp) 		;passing board for "scanMov"
					mov 12(sp),-(sp) 		;passing steps for "scanMov"
					dec (sp) 				;decrementing steps passed for "scanMov"
					mov 12(sp),-(sp) 		;passing current player for "scanMov"
					jsr pc,switchPl 		;inverting player
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack
					mov (sp),14(sp) 		;changing WinParam
					tst (sp)+ 				;clearing stack
					rts pc			 		;returning from subroutine

endPutWP:			mov (sp),16(sp) 		;putting winning parameter into output field
					add #4,sp 				;clearing irrelevant stack area
					mov r4,-(sp)			;saving r4's content
					mov 4(sp),-(sp)			;passing current player as parameter for "minOrMax"
					mov 14(sp),-(sp)		;passing original player as parameter for "minOrMax"
					jsr pc,minOrMax 		;calling "minOrMax"
					add #4,sp 				;clearing stack
					cmp #-1,r4 				;checking if we counted for original player or not
					beq negWP 	 			;if not - negate WP
					mov (sp)+,r4 			;returning r4 to it's initial value
					rts pc  				;returning from subroutine

negWP:				mov (sp)+,r4 			;returning r4 to it's initial value
					neg 12(sp) 				;negating output
					rts pc					;returning from subroutine

scanEJ: 			jmp scanEnd				;jumping to "scanEnd"

scanB:				add #4,sp 				;clearing stack
					mov #-1,-(sp)			;creates an iterator to count steps
					mov 10(sp),-(sp)		;creates a copy of the board address
					sub #2,(sp)				;sets the current address to the word just before the board for convenient iteration

scanLoop:			cmp #1,@#timeOut 		;checking if time is out
					bne sLCont 				;if no - branching to 'SLCont'
					br scanEJ 				;otherwise, branching to 'scanEJ'
sLCont:				add #2,(sp)				;increments the address in order for it to point to the next square
					inc 2(sp)				;increments the number of the square (from 0 to 77)
					cmp 2(sp),#100			;checks if there are any squares left ;should be 77, this is a test version
					bge scanEJ				;if there are none, ends iteration					
					cmp @(sp),6(sp)			;does the square contain the token of the player that was passed to the iterator
					bne scanLoop			;if it doesn't, just continue to iterate over squares

recScan:			mov 2(sp),-(sp)			;passing current source as parameter for "canMoveR"
					mov 2(sp),-(sp) 		;passing board as parameter for "canMoveR"
					mov 12(sp),-(sp) 		;passing current player as parameter for "canMoveR"
					jsr pc,canMoveR 		;calling "canMoveR"
					add #4,sp 				;clearing stack
					cmp #-1,(sp) 			;checking if there are moves on the right path
					beq checkL 				;if no - branching to "checkLeft", otherwise - proceeding
					mov 14(sp),-(sp)		;passing board as parameter for "movPiece"(3 stack elements, last - dest)
					mov 6(sp),src3			;passing current source as parameter for "movPiece"
					mov 2(sp),dst3			;passing found destination as parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
src3:				.word 0 				;inline parameter for "movPiece"
dst3:				.word 0 				;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack(nse=3)
					mov #0,-(sp)     		;passing output field for "scanMov"
					mov 20(sp),-(sp) 		;passing original player as parameter for "scanMov" 
					mov 20(sp),-(sp) 		;passing board as parameter for "scanMov"
					mov 20(sp),-(sp)		;passing steps as parameter for "scanMov"
					dec (sp) 				;decrementing steps passed to "scanMov"
					mov 20(sp),-(sp) 		;passing current player as parameter for "scanMov"
					jsr pc,switchPl 		;inverting current player passed to "scanMov"
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack(nse=4, last=winparam)
					mov #0,-(sp)			;index to identify that we are checking right path(nse=5, last=pathindex)
					cmp 24(sp),2(sp) 		;checking if WP returned by internal "scanMov" is different from current WP
					bne chWP 				;if yes - branching to "chWP", otherwise proceeding to "retPos"
					mov (sp),2(sp)			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retPos 				;branching to "retPos"

checkL:				tst (sp)+ 				;clearing stack
					mov 2(sp),-(sp)			;passing current source as parameter for "canMoveL"
					mov 2(sp),-(sp) 		;passing board as parameter for "canMoveL"
					mov 12(sp),-(sp) 		;passing current player as parameter for "canMoveL"
					jsr pc,canMoveL 		;calling "canMoveL"
					add #4,sp 				;clearing stack
					cmp #-1,(sp) 			;checking if there are moves on the left path
					beq retToL 				;if no - branching to "retToL", otherwise - proceeding
					mov 14(sp),-(sp)		;passing board as parameter for "movPiece"(3 stack elements, last - dest)
					mov 6(sp),src4			;passing current source as parameter for "movPiece"
					mov 2(sp),dst4			;passing found destination as parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
src4:				.word 0 				;inline parameter for "movPiece"
dst4:				.word 0 				;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack(nse=3)
					mov #0,-(sp)     		;passing output field for "scanMov"
					mov 20(sp),-(sp) 		;passing original player as parameter for "scanMov" 
					mov 20(sp),-(sp) 		;passing board as parameter for "scanMov"
					mov 20(sp),-(sp)		;passing steps as parameter for "scanMov"
					dec (sp) 				;decrementing steps passed to "scanMov"
					mov 20(sp),-(sp) 		;passing current player as parameter for "scanMov"
					jsr pc,switchPl 		;inverting current player passed to "scanMov"
					jsr pc,scanMov 			;calling "scanMov"
					add #10,sp 				;clearing stack(nse=4, last=winparam)
					mov #1,-(sp)			;index to identify that we are checking left path(nse=5, last=pathindex)
					cmp 24(sp),2(sp) 		;checking if WP returned by internal "scanMov" is different from current WP
					bne chWP 				;if yes - branching to "chWP", otherwise proceeding to "retPos"
					mov (sp),2(sp)			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retPos 				;branching to "retPos"

retToL:				tst (sp)+ 				;clearing stack
					br scanLoop 			;branching to "scanLoop"

scLoopJ:			jmp scanLoop			;jumping to "scanLoop"

retPos:				mov 16(sp),-(sp)        ;passing board as parameter for "movPiece"
					mov 4(sp),dst34			;passing dest as first parameter for "movPiece"
					mov 10(sp),src34		;passing source as first parameter for "movPiece"
					jsr r5,movPiece 		;calling "movPiece"
dst34:				.word 0 				;inline parameter for "movPiece"
src34:				.word 0					;inline parameter for "movPiece"
					tst (sp)+ 				;clearing stack
					mov (sp),2(sp)			;changing position of path index in stack
					tst (sp)+   			;clearing stack(nse=3, last=pathindex)
					cmp (sp)+,#0 			;checking if path is right
					bne scLoopJ 			;if yes proceeding to check left path, otherwise - continue iteration
					mov #0,-(sp)			;moving junk to the stack
					br checkL				;branching to "checkL"

chWP:				mov r4,-(sp) 			;saving r4's content(nse=6, last=r4cont)
					mov 16(sp),-(sp) 		;passing current player as parameter for "minOrMax"
					mov 26(sp),-(sp) 		;passing original player as parameter for "minOrMax"
					jsr pc,minOrMax  		;calling "minOrMax"
					add #4,sp 				;clearing stack
					cmp #1,r4 				;checking if we need to get maximal WP
					beq chMax 				;if yes - branching to "chMax", otherwise proceeding to "chMin"

chMin:				mov (sp)+,r4 			;returning r4's content to it's initial value(nse=5, last=pathindex)
					cmp 24(sp),2(sp) 		;cheking if current WP is greater that gotten from internal "scanMov"
					bgt asWP 				;if yes - branching to "asWP", otherwise proceeding 
					mov (sp),2(sp) 			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retPos 				;branching to "retPos"

asWP:				mov 2(sp),24(sp)		;assigning internal WP into the output field
					mov (sp),2(sp)	 		;moving path index down the stack
					tst (sp)+				;clearing stack(nse=4, last=pathindex)
					br retPos 				;branching to "retPos"

chMax:				mov (sp)+,r4 			;returning r4's content to it's initial value(nse=5, last=pathindex)
					cmp 24(sp),2(sp) 		;cheking if current WP is less that gotten from internal "scanMov"
					blt asWP 				;if yes - branching to "asWP", otherwise proceeding 
					mov (sp),2(sp) 			;moving path index down the stack
					tst (sp)+				;clearing stack
					br retPos 				;branching to "retPos"

scanEnd:			add #4,sp				;deletes the count of steps and the copy of the board
					rts pc 					;returning from subroutine


;CALC_WP

calcWP:     mov #0, -(sp)		;create a field for the iterator's output
			mov 6(sp), -(sp)	;copy board to pass it to the iterator
			mov 6(sp), -(sp)	;copy player to pass it to the iterator
			mov #addOne, -(sp)	;pass this function to the iterator
			jsr pc, iterator 	;go to the iterator with all that stuff
			mov 6(sp), r4		;put the returned number (the quantity of the player's pieces) into the register
			mov #0, 6(sp)		;set the output field to 0 again
			cmp 2(sp), #1		;change the player that is passed to the iterator (next 4 lines)
			beq setToTwo		
			mov #1, 2(sp)
			br calcOpp			
setToTwo:	mov #2, 2(sp)		
calcOpp:	jsr pc, iterator	;run the iterator with the opponent as player
			sub 6(sp), r4		;subtract the result from r4
			add #10, sp 		;adjust the stack
			rts pc 				;return to main

;ITERATOR

;iterates over a player's pieces on the board and performs on them an operation specified in the function that is passed to it
;receives: output field 10(sp), board 6(sp), player 4(sp), function 2(sp)
iterator:	mov #-1, -(sp)		;creates an iterator to count steps
			mov 10(sp), -(sp)	;creates a copy of the board address
			sub #2, (sp)		;sets the current address to the word just before the board for convenient iteration	
			mov #0, -(sp)		;output field for the function that will be called	
iterLoop:	add #2, 2(sp)		;increments the address in order for it to point to the next square
			inc 4(sp)			;increments the number of the square (from 0 to 77)
			cmp 4(sp), #100		;checks if there are any squares left
			bge iterEnd			;if there are none, ends iteration					
			cmp @2(sp), 12(sp)	;does the square contain the token of the player that was passed to the iterator?
			bne iterLoop		;if it doesn't, just continue to iterate over squares
iterCall:	jsr pc, @10(sp) 	;goes to the passed function
			cmp #-1, (sp)		;check the exit condition
			bne iterLoop		;if it is not met, continue
iterEnd:	mov (sp), 16(sp)	;puts the called function's output into the iterator's output field
			add #6, sp			;deletes the count of steps and the copy of the board
			rts pc 				;returns to the calling function

;ITERATOR HELPER FUNCTIONS

;;ADD_ONE
;helper function that is passed to the iteratior in order to calculate the WP; increments the passed field
addOne:	    inc 2(sp)
			rts pc

;;ANY_PIECE
;helper function used to check if there are any pieces on the board; makes the iterator finish iterating
anyPiece:	mov #-1, 2(sp)			
			rts pc

;;ANY_MOVE
;function that is passed to the iterator in order to check if there are any possible moves for a given piece
;receives: source 6(sp), current address on board 4(sp), output 2(sp)
;if a piece can move right or left, return -1, so that the iterator would stop
anyMove:    mov 6(sp), -(sp)    ;copy source
            mov 6(sp), -(sp)    ;copy address on board
            mov @(sp), -(sp)    ;copy player
callCMR:    jsr pc, canMoveR    ;check if the player can move to the right
            cmp 4(sp), #-1      ;check what was returned from the function
            bne am1             ;if it is not -1 (the piece can move), stop the iteration
            add #6, sp          ;otherwise adjust the stack
            mov 6(sp), -(sp)    ;copy source
            mov 6(sp), -(sp)    ;copy address on board
            mov @(sp), -(sp)    ;copy player
            jsr pc, canMoveL    ;check if the piece can move to the left
            cmp 4(sp), #-1      ;if it is not -1, the piece can move
            bne am1             ;stop the iteration in that case
            add #6, sp          ;otherwise adjust the stack
            rts pc              ;if the piece cannot move, exit without changing the output field
am1:        mov #-1, 10(sp)     ;pass in the output field the number that will stop the iteration
            add #6, sp          ;adjust the stack
            rts pc              ;exit

;CHECK_WIN
;receives: player by value 2(sp), board by address 4(sp), output field 6(sp)
;returns 1 if the player has won, -1 otherwise
;if the player has pieces left, but the opponent doesn't, the player has won
;if both have no moves, and the player has more pieces, the player has won
;reminder: endCond receives: 6(sp) steps, 4(sp) board by address, 2(sp) current player
;and the following output fields: 12(sp) stop (1)/ continue (0) / pass (2), 10(sp) WP in case of a stop

checkWin:	mov #0, -(sp)		;pass the output field to endCond
			mov #0, -(sp)		;pass another output field to endCond
			mov #1, -(sp)		;pass 1 as a number of steps to endCond (checkWin doesn't care if the steps are finished)
			mov 12(sp), -(sp)	;pass board to endCond
			mov 12(sp), -(sp)	;pass player to endCond
			jsr pc, endCond 	;go to endCond
			cmp 10(sp), #1		;check the stop vs continue output field
			bne chWNeg			;if it is not 1, we the player has not won
			cmp 6(sp), #20 		;otherwise check the score output field
			bne chWNeg			;if it is not 20, the current player has not won
chWPos:		add #10, sp 		;adjust the stack
			mov #1, 6(sp)		;return 1 in the output field
			rts pc 				;return to the calling function
chWNeg:		add #10, sp  		;adjust the stack
			mov #-1, 6(sp)		;return -1 in the output field
			rts pc 				;return to the calling function



;CAN_MOVE_R
;function checking if the piece can move to the right
;player 2(sp), board 4(sp), source 6(sp)
canMoveR:   mov #0, -(sp)       ;first vs second check counter (just move vs eat)
            cmp 4(sp), #1       ;row step
            beq wRStep 			;check who's the player
            mov #10, -(sp)      ;row step for Player 1
            br cmrRecur 		;start to check if the move is possible
wRStep:     mov #-10, -(sp) 	;row step for Player2
cmrRecur:   add #1, 2(sp) 		;adjust the square ID
            mov 6(sp), -(sp)    ;copy player
            mov 14(sp), -(sp)   ;copy square ID
            jsr pc, testEdge 	;check if we won't cross the edge of the board
            tst (sp)+ 			;adjust the stack
            cmp (sp)+, #1       ;check border
            bne cmrRetN         ;border check failed => return -1
riEdge:     mov 12(sp), -(sp)   ;check right edge (next 3 lines)
            bic #177770, (sp)  
            cmp (sp)+, #7
            beq cmrRetN         ;return -1 if the right edge condition is not fulfilled
            mov (sp), -(sp)     ;add row step for the current player
            inc (sp)            ;add step to the right
isEmptyR:   mov 12(sp), -(sp)   ;move board to stack
            asl 2(sp)           ;multiply possible dest by two
            add 2(sp), (sp)     ;get the address to check
            tst @(sp) 			;check the contents of the square
            beq retMoveR        ;if it is 0, return dest
            cmp @(sp), 12(sp)   ;compare dest contents with player
            beq cmrRetNN        ;if the player's piece is there, return -1
            cmp 6(sp), #2       ;otherwise check iteration number
            beq cmrRetNN        ;if it is the second iteration, return -1
            asr 2(sp) 			;set the new source
            mov (sp), 14(sp)    ;set new board
            add 2(sp), 16(sp)   ;set new source
            add #4, sp 			;adjust the stack
tryEatR:    br cmrRecur 		;check if we can eat the opponent's piece
cmrRetNN:   add #4, sp 			;adjust the stack
cmrRetN:    add #4, sp 			;adjust the stack
            mov #-1, 6(sp) 		;return -1
            rts pc 				;return to the calling function
retMoveR:   asr 2(sp) 			;set the destination
            add 2(sp), 16(sp)   ;return move
            add #10, sp         ;adjust stack 
            rts pc 				;return to the calling function

;CAN_MOVE_L
;function checking if the player can move to the left
;player 2(sp), board 4(sp), source 6(sp)
canMoveL:   mov #0, -(sp)       ;first vs second check counter (just move vs eat)
            cmp 4(sp), #1       ;row step
            beq wLStep  		;check who's the player
            mov #10, -(sp)      ;row step for Player 1
            br cmlRecur 		;start checking if the move is possible
wLStep:     mov #-10, -(sp) 	;row step for Player 2
cmlRecur:   add #1, 2(sp) 		;adjust the counter
            mov 6(sp), -(sp)    ;copy player
            mov 14(sp), -(sp)   ;copy square ID
            jsr pc, testEdge 	;check if we would cross the top/bottom edge
            tst (sp)+			;adjust the stack
            cmp (sp)+, #1       ;check border
            bne cmlRetN         ;border check failed => return -1
leEdge:     mov 12(sp), -(sp)   ;check right edge (next 3 lines)
            bic #177770, (sp) 	
            cmp (sp)+, #0
            beq cmlRetN         ;return -1 if the right edge condition is not fulfilled
            mov (sp), -(sp)     ;add row step for the current player
            dec (sp)            ;add step to the left
isEmptyL:   mov 12(sp), -(sp)   ;move board to stack
            asl 2(sp)           ;multiply possible dest by two
            add 2(sp), (sp)     ;get the address to check
            tst @(sp)
            beq retMoveL        ;if it is 0, return dest
            cmp @(sp), 12(sp)   ;compare dest contents with player
            beq cmlRetNN        ;if the player's piece is there, return -1
            cmp 6(sp), #2       ;otherwise check iteration number
            beq cmlRetNN        ;if it is the second iteration, return -1
            asr 2(sp)			;adjust the source
            mov (sp), 14(sp)    ;set new board
            add 2(sp), 16(sp)   ;set new source
            add #4, sp 			;adjust the stack
tryEatL:    br cmlRecur 		;check if the opponent's piece can be eaten
cmlRetNN:   add #4, sp 			;adjust the stack
cmlRetN:    add #4, sp 			;adjust the stack
            mov #-1, 6(sp) 		;return -1
            rts pc 				;return to the calling function
retMoveL:   asr 2(sp) 			;adjust the destination
            add 2(sp), 16(sp)   ;return move
            add #10, sp         ;adjust stack 
            rts pc 				;return to the calling function


;TEST_EDGE
;helper function that is used to check if the player is close to the top or bottom of the board and cannot move
;passed are player ID 4(sp) and square ID 2(sp)
;returns result in 4(sp)
;tests if the player is close to the edge of the board
testEdge:   mov 2(sp), -(sp)	;we'll need to check the square ID
            bic #177707, (sp)	;we leave only the octal digit that is the last before one
            cmp 6(sp), #1       ;check if player is 1
            bne blaEdge			;if they are not, check the black version
whiEdge:    cmp (sp), #0		;otherwise check if the digit that was left is 0
            beq edgeNeg			;if it is so, the white player cannot move
            br edgePos 			;if it is not, the edge condition is fulfilled
blaEdge:    cmp (sp), #70 		;if the player is player 2, check if the last digit before one is 7
            beq edgeNeg 		;if it is so, the player cannot move
edgePos:    mov #1, 6(sp)		;if the player can move, return -1
            tst (sp)+			;adjust the stack
            rts pc 				;return to the calling function
edgeNeg:    mov #-1, 6(sp) 		;if the player cannot move, return -1
            tst (sp)+			;adjust the stack
            rts pc 				;return to the calling function

;END_COND
;receives: 6(sp) steps, 4(sp) board by address, 2(sp) current player
;and the following output fields: 12(sp) stop (1)/ continue (0) / pass (2), 10(sp) WP in case of a stop

endCond:    mov #0,12(sp)           ;intitializing output field
            mov #0,-(sp)            ;passing output field for "iterator"
            mov 6(sp),-(sp)         ;passing board as parameter for "iterator"
            mov 6(sp),-(sp)         ;passing current player as parameter for "iterator"
            mov #anyPiece,-(sp)     ;passing "anyPiece" as parameter for "iterator"
            jsr pc,iterator         ;calling "iteartor"
            add #6,sp               ;clearing stack
            cmp (sp)+,#-1           ;checking if there pieces on the board for current player
            beq chCont1             ;if yes - braching to "chCont1", otherwise - proceeding to "retLos"

retLos:     mov #1,12(sp)           ;passing stop flag into output field
            mov #-20,10(sp)         ;passing relevant WP into output field
            rts pc                  ;returning from subroutine

chCont1:    mov #0,-(sp)            ;passing output field for "iterator"
            mov 6(sp),-(sp)         ;passing board as parameter for "iterator"
            mov 6(sp),-(sp)         ;passing current player as parameter for "iterator"
            jsr pc,switchPl         ;inverting player passed to iterator
            mov #anyPiece,-(sp)     ;passing "anyPiece" as parameter for "iterator"
            jsr pc,iterator         ;calling "iteartor"
            add #6,sp               ;clearing stack
            cmp (sp)+,#-1           ;checking if there pieces on the board for opp of current player
            beq chCont2             ;if yes - branching to "chCont2", otherwise proceeding to "retWin"

retWin:     mov #1,12(sp)           ;passing stop flag into output field
            mov #20,10(sp)          ;passing relevant WP into output field
            rts pc                  ;returning from subroutine

chCont2:    mov #0,-(sp)            ;passing output field for "iterator"
            mov 6(sp),-(sp)         ;passing board as parameter for "iterator"
            mov 6(sp),-(sp)         ;passing current player as parameter for "iterator"
            mov #anyMove,-(sp)      ;passing "anyMove" as parameter for "iterator"
            jsr pc,iterator         ;calling "iteartor"
            add #6,sp               ;clearing stack
            cmp (sp)+,#-1           ;checking if there are moves on the board for current player
            beq chCont3             ;if yes - branching to "chCont3", otherwise proceeding to "rWPBoard"
            mov #0,-(sp)            ;passing output field for "iterator"
            mov 6(sp),-(sp)         ;passing board as parameter for "iterator"
            mov 6(sp),-(sp)         ;passing current player as parameter for "iterator"
            jsr pc,switchPl         ;inverting player passed to iterator
            mov #anyMove,-(sp)      ;passing "anyMove" as parameter for "iterator"
            jsr pc,iterator         ;calling "iteartor"
            add #6,sp               ;clearing stack
            cmp (sp)+,#-1 			;checking if there are moves for current player's opponent
            bne rWPBoard 			;if no - branching to "rWPBoard"
            tst 6(sp)
            bne retPasP
            br retPara
retPasP:    mov #2,12(sp) 			;passing pass flag to output
            rts pc 					;returning from subroutine

rWPBoard:   mov #1,12(sp)           ;moving stop flag to the output
            mov r4,-(sp)            ;saving r4's content
            mov 6(sp),-(sp)         ;passing board as parameter for "calcWP"
            mov 6(sp),-(sp)         ;passing current player as parameter for "calcWP"
            jsr pc,calcWP           ;calling "calcWP"
            add #4,sp               ;clearing stack
            cmp r4,#0               ;comparing "calcWP" output with 0
            bgt jToWin              ;if greater - branch to "jToWin"
            blt jToLos              ;less - branch to "jToLos"
            mov r4,12(sp)           ;equal - pass r4's content to output
            mov (sp)+,r4            ;return r4's content
            rts pc                  ;return from subroutine
 
jToLos:     mov (sp)+,r4            ;return r4's content 
            jmp retLos              ;jump to "retLos"

jToWin:     mov (sp)+,r4            ;return r4's content 
            jmp retWin              ;jump to "retWin"

chCont3:    tst 6(sp)               ;checking if number of steps is zero 
            beq retPara             ;if yes - branching to "retPara"
            mov #0,12(sp)           ;passing continue flag into output
            rts pc                  ;otherwise return from subroutine

retPara:    mov #1,12(sp)           ;moving stop flag to the output
            mov r4,-(sp)            ;saving r4's content
            mov 6(sp),-(sp)         ;passing board as parameter for "calcWP"
            mov 6(sp),-(sp)         ;passing current player as parameter for "calcWP"
            jsr pc,calcWP           ;calling "calcWP"
            add #4,sp               ;clearing stack
            mov r4,12(sp)           ;putting r4's content into output field
            mov (sp)+,r4            ;returning r4's initial content
            rts pc                  ;returning from subroutine


;"movPiece" function, does a move supported with a given source and destination
;first parameter[2(sp) - at the start of subroutine] - adress of the board
;second parameter - source point(inline)
;third parameter - destination point(inline)

movPiece:			mov (r5)+,-(sp)					;fetching second parameter
					mov (r5)+,-(sp)					;fetching third parameter
					mov (sp),-(sp)					;creating stack variable for calculating diagonal midpoint
					add 4(sp),(sp)					;adding source and destination indexes
					asr (sp)						;dividing sum of source and destination indexes by two
					bcc capMov 						;if number is divisible by two - checking capture(or reverse capture) move

nCapMov:			tst (sp)+						;if number is no divisible by two - checking simple move, getting rid of calculated sum
					asl (sp)						;multiplying by two destination index
					asl 2(sp)						;multiplying by two source index
					add 6(sp),(sp)					;adding adress of the "Board" to the destination index(multiplied)
					add 6(sp),2(sp)					;adding adress of the "Board" to the source index(multiplied)
					mov @2(sp),@(sp)				;moving source content to the destination
					mov #0,@2(sp)					;clearing the source

retMP:				tst (sp)+						;clearing the stack
					tst (sp)+						;clearing the stack
					rts r5							;returning from the subroutine using connection register(r5)

capMov:				asl 2(sp)						;multiplying by two destination index
					asl 4(sp)						;multiplying by two source index
					asl (sp)						;multiplying by two midpoint index
					add 10(sp),2(sp)				;adding adress of the "Board" to the destination index(multiplied)				
					add 10(sp),4(sp)				;adding adress of the "Board" to the source index(multiplied)
					add 10(sp),(sp)					;adding adress of the "Board" to the midpoint index(multiplied)
					mov @4(sp),@2(sp)				;moving source content to the destination
					mov #0,@4(sp)					;clearing the source
					cmp #0,@(sp)					;checking if midpoint contains any checker
					bne eat 						;if it does - branching to the "eat", if doesn't - proceeding with "revEat"(reverse eat)

revEat:				cmp #1,@2(sp)					;checking if checker that moved was white
					beq bRevEat						;if yes, that branching to the "bRevEat"(reverse eating of the black checker), if no - "wRevEat"

wRevEat:			mov #1,@(sp)					;moving white checker to the midpoint
					tst (sp)+						;clearing stack variable which has contained adress of the midpoint
					jmp retMP						;jumping to the return from the subroutine procedure

bRevEat:			mov #2,@(sp)					;moving black checker to the midpoint
					tst (sp)+						;clearing stack variable which has contained adress of the midpoint
					jmp retMP 						;jumping to the return from the subroutine procedure

eat:				mov #0,@(sp) 					;clearing midpoint
					tst (sp)+						;clearing stack variable which has contained adress of the midpoint
					jmp retMP 						;jsumping to the return from the subroutine procedure	


;"minOrMax" function, decides whether we need to calculate min or max WP in a given turn
;first parameter[4(sp)] - current player
;second parameter[2(sp)] - player we are checking for

minOrMax:		mov @2(sp),-(sp)			;fetching second parameter
				cmp (sp),6(sp)				;comparing player's colors
				beq max 					;if colors are equal - returning "1"(means max)

min:			mov #-1,r4					;in case they are different - returning "-1"(means min)
				jmp return 					;after assigning right value to the r4 going to clear stack and return from subroutine

max:			mov #1,r4  					;assigning "1"(means max) to the r4
				jmp return 					;going to clear the stack and return from subroutine

return:			tst (sp)+					;clearing the stack
				rts pc						;returning from the subroutine




;Gives any field which contains piece of a given player
;Output field 6(sp)
;Board 4(sp)
;Current player 2(sp)
getAnyF:	mov #-1, -(sp)		;creates an iterator to count steps
			mov 6(sp), -(sp)	;creates a copy of the board address
			sub #2, (sp)		;sets the current address to the word just before the board for convenient iteration

gAFLoop:	add #2, (sp)		;increments the address in order for it to point to the next square
			inc 2(sp)			;increments the number of the square (from 0 to 77)
			cmp 2(sp), #100		;checks if there are any squares left
			bge retFGAF			;if there are none, ends iteration					
			cmp @(sp), 6(sp)	;does the square contain the token of the player that was passed to the iterator?
			bne gAFLoop			;if it doesn't, just continue to iterate over squares

rField:		mov 2(sp),12(sp)	;passing field index into output	

retFGAF:	add #4,sp 			;clearing stack
			rts pc 				;returns to the calling function


;SWITCH_PL
;function used to switch from Player 1 to Player 2 inside a function
;when given 1, returns 2 in the same field 2(sp), and vice versa
switchPl:   cmp 2(sp), #1 			;checking if passed player is white
            beq retBl 				;if yes, change him into black
            mov #1, 2(sp) 			;otherwise change him into white
            rts pc 					;return from subroutine
retBl:      mov #2, 2(sp) 			;change palyer into black
            rts pc 					;return from subroutine
			

.=torg+11000
Board:
.word 0,0,0,0,0,0,0,0
.word 0,0,2,0,2,0,0,0
.word 0,0,0,1,0,0,0,0
.word 0,0,0,0,2,0,0,0
.word 0,0,0,1,0,0,0,0
.word 0,0,1,0,1,0,0,0
.word 0,0,0,0,0,2,0,0
.word 0,0,0,0,0,0,0,0
Player:.word 1
Steps:.word 3

;output
SrcPos: .blkw 1
DstPos: .blkw 1
WinParam: .blkw 1

